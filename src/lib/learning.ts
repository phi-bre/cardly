import type { Card, CardAnswer } from './interfaces';

// TODO: This code was generated by Chad G. Pete the 4th, check if this is good at all at some point. Can't be bothered right now.

export interface CardLevel {
  title: string;
  timing: number;
}

export enum CardLevels {
  New = 0,
  Learning = 1,
  Reviewing = 2,
  Mastered = 3,
}

export const levels: Record<CardLevels, CardLevel> = {
  [CardLevels.New]: { title: 'New', timing: 0 },
  [CardLevels.Learning]: { title: 'Learning', timing: 5 * 60 * 1000 },
  [CardLevels.Reviewing]: { title: 'Reviewing', timing: 15 * 60 * 1000 },
  [CardLevels.Mastered]: { title: 'Mastered', timing: 60 * 60 * 1000 },
};

export function getLevelForCard(card: Card, cardAnswers: CardAnswer[]): CardLevels {
  const cardAnswerHistory = cardAnswers.filter((answer) => answer.card === card.id);

  if (!cardAnswerHistory.length) {
    return CardLevels.New;
  }

  const recentAnswers = cardAnswerHistory.slice(-3);
  const averageAccuracy =
    recentAnswers.reduce((sum, answer) => sum + answer.accuracy, 0) / recentAnswers.length;

  if (averageAccuracy >= 0.5 && cardAnswerHistory.length > 1) {
    if (recentAnswers.every((answer) => answer.accuracy >= 0.85) && cardAnswerHistory.length > 2) {
      return CardLevels.Mastered;
    } else {
      return CardLevels.Reviewing;
    }
  } else {
    return CardLevels.Learning;
  }
}

export function shouldCardBeLearned(card: Card, cardAnswers: CardAnswer[]): boolean {
  const now = Date.now();

  const levelIndex = getLevelForCard(card, cardAnswers);
  const cardAnswer = cardAnswers.filter((answer) => answer.card === card.id).pop();

  if (!cardAnswer) {
    return true;
  }

  const nextReviewTime = cardAnswer.time + levels[levelIndex].timing;
  return nextReviewTime <= now;
}
